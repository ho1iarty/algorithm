/****************************************************************
题目：一个整数列，除了一个数字重复2次，所有其他数字都重复4次。
    O(n)时间O(1)空间找到那个只出现2次的。
提示：所有数字的二进制第0位统计，0有多少个，1有多少个，
    比如1的个数是除4余2的，则得知要找的那个数的二进制第0位为1。
    其他二进制位同样。
*****************************************************************/

#include <iostream>
using namespace std;

unsigned int findTwice(unsigned int a[], int n)
{
    //m[4]为存储每一个二进制位为1的个数被4除的余数
    //mb为临时变量
    unsigned int m[4] = {-1, 0, 0, 0}, mb;
    for(int i = 0; i < n; i++)
    {
        mb= m[3];
        //仅解释第一行，其它类似：
        //如果m[3]不为0，则说明之前统计的方该位的个数除4余3，走(m3 & ~ai)部分
        //      那么，如果a[i]的这一位为0，则不变；若为1，则余数变为0，m[3]=0；
        //如果m[3]为0，说明余数不为3，"|" 的左边肯定为0，则走右边
        //      从余数为2进行判断，与上面过程相似
        m[3]= (m[3] & ~a[i]) | (m[2] & a[i]);
        m[2]= (m[2] & ~a[i]) | (m[1] & a[i]);
        m[1]= (m[1] & ~a[i]) | (m[0] & a[i]);
        m[0]= (m[0] & ~a[i]) | (mb & a[i]);
    }
    return m[2];
}

int main()
{
    //unsigned int test[] = {5, 1, 2, 5, 2, 2, 2, 1, 1, 1, 3, 3, 3, 3};
    unsigned int test[] = {5, 6, 1123,5, 5, 6, 6, 7, 6, 7, 7, 1123, 5,7};
    unsigned int rt;
    rt = findTwice(test, 14);
    cout<< rt << endl;
    return 0;
}
